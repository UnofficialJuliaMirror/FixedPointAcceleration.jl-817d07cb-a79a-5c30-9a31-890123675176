<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>4 Applications · FixedPointAcceleration</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FixedPointAcceleration</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">FixedPointAcceleration.jl</a></li><li><a class="toctext" href="../1_FixedPoints/">1 Fixed point acceleration</a></li><li><a class="toctext" href="../2_Algorithms/">2 Acceleration algorithms</a></li><li><a class="toctext" href="../3_UsingAdvice/">3  Using the FixedPointAcceleration package</a></li><li class="current"><a class="toctext" href>4 Applications</a><ul class="internal"><li><a class="toctext" href="#.1-Finding-equilibrium-prices-in-a-pure-exchange-economy-1">4.1 Finding equilibrium prices in a pure exchange economy</a></li></ul></li><li><a class="toctext" href="../4___Perceptron/">4 Applications</a></li><li><a class="toctext" href="../4___ExpectationMaximisation/">4 Applications</a></li><li><a class="toctext" href="../4___ConsumptionSmoothing/">4 Applications</a></li><li><a class="toctext" href="../4___ConfidenceHypercube/">4 Applications</a></li><li><a class="toctext" href="../5_TerminationConditions/">5 Termination conditions and Error handling.</a></li><li><a class="toctext" href="../99_refs/">References</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>4 Applications</a></li></ul><a class="edit-page" href="https://github.com/s-baumann/FixedPointAcceleration.jl/blob/master/docs/src/4___EquilibriumPriceVector.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>4 Applications</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Applications-1" href="#Applications-1">4 Applications</a></h1><h2><a class="nav-anchor" id=".1-Finding-equilibrium-prices-in-a-pure-exchange-economy-1" href="#.1-Finding-equilibrium-prices-in-a-pure-exchange-economy-1">4.1 Finding equilibrium prices in a pure exchange economy</a></h2><p>Consider that there are N households in a pure exchange economy. Every household has preferences over G types of good. Household <span>$n$</span> has a utility function of</p><div>\[U_n = \sum_{i=1}^G \gamma_{n,i} \log(c_{n,i})\]</div><p>Where <span>$\gamma_{n,i}$</span> is a parameter describing household <span>$n$</span>&#39;s taste for good <span>$i$</span>, <span>$c_{n,i}$</span> is household <span>$n$</span>&#39;s consumption of good <span>$i$</span>. Each household is endowed with an amount of each good. They can then trade goods before consumption. We want to find the equilibrium prices in this exchange economy. We have data on each household&#39;s endowment and preferences for each good and want to determine the equilibrium prices for this pure exchange economy.</p><p>We will choose good 1 as the numeraire. So <span>$P_1 = 1$</span>. First we will find an expression for demand given a price vector. Setting up the lagrangian for household <span>$n$</span>:</p><div>\[L_n = \sum_{i=1}^G \gamma_{n,i} \log(c_{n,i}) + \lambda_{n}[ \sum_{i=1}^G p_i(e_{n,i}-c_{n,i}) ]\]</div><p>Where <span>$\lambda_{n}$</span> is household <span>$n$</span>&#39;s shadow price and <span>$e_{n,i}$</span> is this household&#39;s endowment of good <span>$i$</span> and <span>$p_i$</span> is the price of good <span>$i$</span>. Taking FOC with respect to <span>$c_i$</span> of this lagrangian yields:</p><div>\[c_{n,i} = \frac{\gamma_{n,i}}{p_i \lambda_n}\]</div><p>and taking FOC condition with respect to <span>$\lambda_n$</span> yields the budget constraint. Subbing the above equation into the budget constrain and rearranging yields:</p><div>\[\lambda_n = \frac{\sum^G_{i=1} \gamma_{n,i}}{\sum^G_{i=1} p_i e_{n,i}}\]</div><p>We can also sum over households to find total demand for each good as:</p><div>\[D_i = \frac{1}{P_i} \sum_{n=1}^G \frac{\gamma_{n,i}}{\lambda_n}\]</div><p>We will find the equilibrium price vector by using an approximate price vector to find the <span>$\lambda$</span>s. We can then find an estimate of the equilibrium price <span>$P_i$</span> which solves <span>$D_i = \sum_{n=1}^G e_{n,i}$</span>:</p><div>\[P_i = \frac{\sum_{n=1}^G e_{n,i}}{\sum_{n=1}^G \frac{\gamma_{n,i}}{\lambda_n} }\]</div><p>We use this approach in the code below for the case of 10 goods with 8 households. For exposition sake we generate some data below before proceeding to find the equilibrium price vector.</p><pre><code class="language-none"># Generating data
using Distributions
using FixedPointAcceleration
using Random
Random.seed!(1234)
N = 5
G = 10
Endowments = rand(LogNormal(), G, N)
Tastes      = rand(G, N)
# Every column here represents a household and every row is a good. So Endowments[1,2] is
# the second household&#39;s endowment of good 1.

# We now start solving for equilibrium prices:
TotalEndowmentsPerGood = mapslices(sum, Endowments; dims = [2])
TotalTastesPerHousehold = mapslices(sum, Tastes; dims = [1])

function LambdasGivenPriceVector(prices)
    ValueOfEndowmentsPerHousehold = prices .* Endowments
    TotalValueOfEndowmentsPerHousehold =  mapslices(sum, ValueOfEndowmentsPerHousehold; dims = [1])
    return TotalTastesPerHousehold ./ TotalValueOfEndowmentsPerHousehold
end

function IterateOnce(prices)
    Lambdas = LambdasGivenPriceVector(prices)
    TastesOverLambdas = Tastes ./ Lambdas
    SumTastesOverLambdas = mapslices(sum, TastesOverLambdas; dims = [2])
    NewPrices = SumTastesOverLambdas ./ TotalEndowmentsPerGood
    NewPrices = NewPrices/NewPrices[1] # Applying Numeraire
    return NewPrices
end


InitialGuess = repeat([1.0], 10)
FPSolution = fixed_point(IterateOnce, InitialGuess; Algorithm = VEA)</code></pre><footer><hr/><a class="previous" href="../3_UsingAdvice/"><span class="direction">Previous</span><span class="title">3  Using the FixedPointAcceleration package</span></a><a class="next" href="../4___Perceptron/"><span class="direction">Next</span><span class="title">4 Applications</span></a></footer></article></body></html>
