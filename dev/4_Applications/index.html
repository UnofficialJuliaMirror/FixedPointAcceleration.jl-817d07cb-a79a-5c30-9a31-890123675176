<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>4.0 Applications · FixedPointAcceleration</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FixedPointAcceleration</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">FixedPointAcceleration.jl</a></li><li><a class="toctext" href="../1_FixedPoints/">1 Fixed point acceleration</a></li><li><a class="toctext" href="../2_Algorithms/">2 Acceleration algorithms</a></li><li><a class="toctext" href="../3_UsingAdvice/">3.  Using the FixedPointAcceleration package</a></li><li class="current"><a class="toctext" href>4.0 Applications</a><ul class="internal"><li><a class="toctext" href="#.1-Finding-equilibrium-prices-in-a-pure-exchange-economy-1">4.1 Finding equilibrium prices in a pure exchange economy</a></li><li><a class="toctext" href="#.2-A-consumption-smoothing-problem-1">4.2 A consumption smoothing problem</a></li></ul></li><li><a class="toctext" href="../99_refs/">References</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>4.0 Applications</a></li></ul><a class="edit-page" href="https://github.com/s-baumann/FixedPointAcceleration.jl/blob/master/docs/src/4_Applications.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>4.0 Applications</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id=".0-Applications-1" href="#.0-Applications-1">4.0 Applications</a></h1><h2><a class="nav-anchor" id=".1-Finding-equilibrium-prices-in-a-pure-exchange-economy-1" href="#.1-Finding-equilibrium-prices-in-a-pure-exchange-economy-1">4.1 Finding equilibrium prices in a pure exchange economy</a></h2><p>Consider that there are N households in a pure exchange economy. Every household has preferences over G types of good. Household <span>$n$</span> has a utility function of</p><div>\[U_n = \sum_{i=1}^G \gamma_{n,i} \log(c_{n,i})\]</div><p>Where <span>$\gamma_{n,i}$</span> is a parameter describing household <span>$n$</span>&#39;s taste for good <span>$i$</span>, <span>$c_{n,i}$</span> is household <span>$n$</span>&#39;s consumption of good <span>$i$</span>. Each household is endowed with an amount of each good. They can then trade goods before consumption. We want to find the equilibrium prices in this exchange economy. We have data on each household&#39;s endowment and preferences for each good and want to determine the equilibrium prices for this pure exchange economy.</p><p>We will choose good 1 as the numeraire. So <span>$P_1 = 1$</span>. First we will find an expression for demand given a price vector. Setting up the lagrangian for household <span>$n$</span>:</p><div>\[L_n = \sum_{i=1}^G \gamma_{n,i} \log(c_{n,i}) + \lambda_{n}[ \sum_{i=1}^G p_i(e_{n,i}-c_{n,i}) ]\]</div><p>Where <span>$\lambda_{n}$</span> is household <span>$n$</span>&#39;s shadow price and <span>$e_{n,i}$</span> is this household&#39;s endowment of good <span>$i$</span> and <span>$p_i$</span> is the price of good <span>$i$</span>. Taking FOC with respect to <span>$c_i$</span> of this lagrangian yields:</p><div>\[c_{n,i} = \frac{\gamma_{n,i}}{p_i \lambda_n}\]</div><p>and taking FOC condition with respect to <span>$\lambda_n$</span> yields the budget constraint. Subbing the above equation into the budget constrain and rearranging yields:</p><div>\[\lambda_n = \frac{\sum^G_{i=1} \gamma_{n,i}}{\sum^G_{i=1} p_i e_{n,i}}\]</div><p>We can also sum over households to find total demand for each good as:</p><div>\[D_i = \frac{1}{P_i} \sum_{n=1}^G \frac{\gamma_{n,i}}{\lambda_n}\]</div><p>We will find the equilibrium price vector by using an approximate price vector to find the <span>$\lambda$</span>s. We can then find an estimate of the equilibrium price <span>$P_i$</span> which solves <span>$D_i = \sum_{n=1}^G e_{n,i}$</span>:</p><div>\[P_i = \frac{\sum_{n=1}^G e_{n,i}}{\sum_{n=1}^G \frac{\gamma_{n,i}}{\lambda_n} }\]</div><p>We use this approach in the code below for the case of 10 goods with 8 households. For exposition sake we generate some data below before proceeding to find the equilibrium price vector.</p><pre><code class="language-none"># Generating data
using Distributions
using FixedPointAcceleration
using Random
Random.seed!(1234)
N = 5
G = 10
Endowments = rand(LogNormal(), G, N)
Tastes      = rand(G, N)  
# Every column here represents a household and every row is a good. So Endowments[1,2] is
# the second household&#39;s endowment of good 1.

# We now start solving for equilibrium prices:
TotalEndowmentsPerGood = mapslices(sum, Endowments; dims = [2])
TotalTastesPerHousehold = mapslices(sum, Tastes; dims = [1])

function LambdasGivenPriceVector(prices)
    ValueOfEndowmentsPerHousehold = prices .* Endowments
    TotalValueOfEndowmentsPerHousehold =  mapslices(sum, ValueOfEndowmentsPerHousehold; dims = [1])
    return TotalTastesPerHousehold ./ TotalValueOfEndowmentsPerHousehold
end

function IterateOnce(prices)
    Lambdas = LambdasGivenPriceVector(prices)
    TastesOverLambdas = Tastes ./ Lambdas
    SumTastesOverLambdas = mapslices(sum, TastesOverLambdas; dims = [2])
    NewPrices = SumTastesOverLambdas ./ TotalEndowmentsPerGood
    NewPrices = NewPrices/NewPrices[1] # Applying Numeraire
    return NewPrices
end


InitialGuess = repeat([1.0], 10)
FPSolution = fixed_point(IterateOnce, InitialGuess; Algorithm = VEA)</code></pre><h2><a class="nav-anchor" id=".2-A-consumption-smoothing-problem-1" href="#.2-A-consumption-smoothing-problem-1">4.2 A consumption smoothing problem</a></h2><p>Consider an infinitely lived consumer that has a budget of <span>$B_t$</span> at time <span>$t$</span> and a periodic income of <span>$1$</span>. She has a periodic utility function given by <span>$\epsilon_t x_t^\delta$</span>, where <span>$x_t$</span> is spending in period <span>$t$</span> and <span>$\epsilon_t$</span> is the shock in period <span>$t$</span> drawn from some stationary nonnegative shock process with pdf <span>$f(\epsilon)$</span> defined on the interval <span>$[y,z]$</span>. The problem for the consumer in period <span>$t$</span> is to maximise their value function:</p><div>\[V(B_t | \epsilon_{t}) =  \max_{0 &lt; x_t &lt; B_t} \hspace{0.5cm} \epsilon_t x_t^\delta + \beta \int_y^z V(B_{t+1} | \epsilon) f(\epsilon)d\epsilon\]</div><p>Where <span>$\beta$</span> is a discounting factor and <span>$B_{t+1} = 1 + B_t - x_t$</span>.</p><p>Our goal is that we want to find a function that gives the optimal spending amount, <span>$\hat{x}(B_t, \epsilon_t)$</span>,  in period <span>$t$</span> which is a function of the shock magnitude <span>$\epsilon_{t}$</span> and the saved budgets <span>$B_{t}$</span> in this period. If we knew the function <span>$\int_y^z V(B_{t+1} \vert \epsilon) f(\epsilon)d\epsilon$</span> then we could do this by remembering <span>$B_{t+1} = 1 + B_t - x_t$</span> and using the optimisation:</p><div>\[\hat{x}(B_t, \epsilon_t) = \text{argmax}_{0 &lt; x_t &lt; B_t} \hspace{0.5cm} \epsilon_t x_t^\delta + \beta \int_y^z V(B_{t+1} | \epsilon) f(\epsilon)d\epsilon\]</div><p>So now we need to find the function <span>$E_t[ V(B_{t+1})]$</span>. Note as the shock process is stationary, the consumer lives forever and income is always 1, <span>$E_t[ V(B_{t+1})]$</span> will not vary with <span>$t$</span>. As a result we will rewrite it as simply <span>$f(b)$</span>.</p><p>Now we will construct a vector containing a grid of budget values, <span>$\bar{b}$</span>, for instance <span>$\bar{b} = [0, 0.01,0.02, ... , 5]$</span> (we will use bars to describe approximations gained from this grid). If we could then approximate a vector of the corresponding function values, <span>$\bar{f}$</span>,  so we had for instance <span>$\bar{f} = [f(0), f(0.01), f(0.02), ... , f(5)]$</span> then we could approximate the function by constructing a spline <span>$\bar{f}(b)$</span> between these points. Then we can get the function:</p><div>\[\bar{x}(B_t, \epsilon_t) = \text{argmax}_{0 &lt; x &lt; B_t} \hspace{0.5cm} \epsilon_t x_t^{\delta} + \bar{f}(B_{t} - x)]\]</div><p>So this problem reduces to finding the vector of function values at a discrete number of points, <span>$\bar{f}$</span>. This can be done as a fixed point problem. We can first note that this problem is a contraction mapping problem. In this particular example this means that if we define a sequence <span>$\bar{f}_0 = f_0$</span> where <span>$f_0$</span> is some initial guess and <span>$f_i = g(f_{i-1})$</span> where <span>$g$</span> is given by the IterateOnce function below then this sequence will be convergent. Convergence would be slow however so below we will actually use the Anderson method:</p><pre><code class="language-none">using Distributions
using FixedPointAcceleration
using HCubature
using Optim
using Random
using SchumakerSpline
delta = 0.2
beta = 0.95
periodic_income = 1.0
shock_var = 1.0
shock_process = LogNormal(0.0, shock_var)
BudgetStateSpace = vcat( collect(0:0.015:periodic_income), collect(1.05:0.05:(3*periodic_income)))
InitialGuess = sqrt.(BudgetStateSpace)

function ValueGivenShock(Budget::Float64, epsilon::Float64, NextValueFunction::Schumaker)
    opt = optimize(x -&gt;  -1.0*(epsilon*(x^delta) + beta*evaluate(NextValueFunction, Budget - x + periodic_income)), 0.0, Budget)
    return -1.0 * opt.minimum
end

function ExpectedUtility(Budget::Float64, NextValueFunction::Schumaker)
    if Budget &gt; 0.00001
        integ = hcubature(epsilon-&gt; ValueGivenShock(Budget, epsilon[1], NextValueFunction)* pdf(shock_process, epsilon[1]), [quantile(shock_process,0.0001)], [quantile(shock_process, 0.9999)])
        return integ[1]
    else
        return beta * evaluate(NextValueFunction, periodic_income)
    end
end

function OneIterateBudgetValues(BudgetValues::Array{Float64,1})
    NextValueFunction = Schumaker(BudgetStateSpace, BudgetValues)
    new_budget_values = zeros(length(BudgetStateSpace))
    for i in 1:length(BudgetStateSpace)
        new_budget_values[i] = ExpectedUtility(BudgetStateSpace[i], NextValueFunction)
    end
    return new_budget_values
end

fp_anderson = fixed_point(OneIterateBudgetValues, InitialGuess; Algorithm = Anderson, PrintReports = true)
fp_simple   = fixed_point(OneIterateBudgetValues, InitialGuess; Algorithm = Simple, PrintReports = true)</code></pre><p>This takes 22 iterates with the anderson algorithm which is drastically better than the several hundred iterates it takes with the simple method.</p><footer><hr/><a class="previous" href="../3_UsingAdvice/"><span class="direction">Previous</span><span class="title">3.  Using the FixedPointAcceleration package</span></a><a class="next" href="../99_refs/"><span class="direction">Next</span><span class="title">References</span></a></footer></article></body></html>
