<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>- · FixedPointAcceleration</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FixedPointAcceleration</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">FixedPointAcceleration.jl</a></li><li><a class="toctext" href="../1_FixedPoints/">1 Fixed point acceleration</a></li><li><a class="toctext" href="../2_Algorithms/">2 Acceleration algorithms</a></li><li><a class="toctext" href="../3_UsingAdvice/">3  Using the FixedPointAcceleration package</a></li><li><a class="toctext" href="../4_Applications/">4 Applications</a></li><li><a class="toctext" href="../4___EquilibriumPriceVector/">-</a></li><li><a class="toctext" href="../4___Perceptron/">-</a></li><li><a class="toctext" href="../4___ExpectationMaximisation/">-</a></li><li class="current"><a class="toctext" href>-</a><ul class="internal"><li><a class="toctext" href="#.4-A-consumption-smoothing-problem-1">4.4 A consumption smoothing problem</a></li></ul></li><li><a class="toctext" href="../5_TerminationConditions/">5 Termination conditions and Error handling.</a></li><li><a class="toctext" href="../99_refs/">References</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>-</a></li></ul><a class="edit-page" href="https://github.com/s-baumann/FixedPointAcceleration.jl/blob/master/docs/src/4___ConsumptionSmoothing.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>-</span><a class="fa fa-bars" href="#"></a></div></header><h2><a class="nav-anchor" id=".4-A-consumption-smoothing-problem-1" href="#.4-A-consumption-smoothing-problem-1">4.4 A consumption smoothing problem</a></h2><p>Consider an infinitely lived consumer that has a budget of <span>$B_t$</span> at time <span>$t$</span> and a periodic income of <span>$1$</span>. She has a periodic utility function given by <span>$\epsilon_t x_t^\delta$</span>, where <span>$x_t$</span> is spending in period <span>$t$</span> and <span>$\epsilon_t$</span> is the shock in period <span>$t$</span> drawn from some stationary nonnegative shock process with pdf <span>$f(\epsilon)$</span> defined on the interval <span>$[y,z]$</span>. The problem for the consumer in period <span>$t$</span> is to maximise their value function:</p><div>\[V(B_t | \epsilon_{t}) =  \max_{0 &lt; x_t &lt; B_t} \hspace{0.5cm} \epsilon_t x_t^\delta + \beta \int_y^z V(B_{t+1} | \epsilon) f(\epsilon)d\epsilon\]</div><p>Where <span>$\beta$</span> is a discounting factor and <span>$B_{t+1} = 1 + B_t - x_t$</span>.</p><p>Our goal is that we want to find a function that gives the optimal spending amount, <span>$\hat{x}(B_t, \epsilon_t)$</span>,  in period <span>$t$</span> which is a function of the shock magnitude <span>$\epsilon_{t}$</span> and the saved budgets <span>$B_{t}$</span> in this period. If we knew the function <span>$\int_y^z V(B_{t+1} \vert \epsilon) f(\epsilon)d\epsilon$</span> then we could do this by remembering <span>$B_{t+1} = 1 + B_t - x_t$</span> and using the optimisation:</p><div>\[\hat{x}(B_t, \epsilon_t) = \text{argmax}_{0 &lt; x_t &lt; B_t} \hspace{0.5cm} \epsilon_t x_t^\delta + \beta \int_y^z V(B_{t+1} | \epsilon) f(\epsilon)d\epsilon\]</div><p>So now we need to find the function <span>$E_t[ V(B_{t+1})]$</span>. Note as the shock process is stationary, the consumer lives forever and income is always 1, <span>$E_t[ V(B_{t+1})]$</span> will not vary with <span>$t$</span>. As a result we will rewrite it as simply <span>$f(b)$</span>.</p><p>Now we will construct a vector containing a grid of budget values, <span>$\bar{b}$</span>, for instance <span>$\bar{b} = [0, 0.01,0.02, ... , 5]$</span> (we will use bars to describe approximations gained from this grid). If we could then approximate a vector of the corresponding function values, <span>$\bar{f}$</span>,  so we had for instance <span>$\bar{f} = [f(0), f(0.01), f(0.02), ... , f(5)]$</span> then we could approximate the function by constructing a spline <span>$\bar{f}(b)$</span> between these points. Then we can get the function:</p><div>\[\bar{x}(B_t, \epsilon_t) = \text{argmax}_{0 &lt; x &lt; B_t} \hspace{0.5cm} \epsilon_t x_t^{\delta} + \bar{f}(B_{t} - x)]\]</div><p>So this problem reduces to finding the vector of function values at a discrete number of points, <span>$\bar{f}$</span>. This can be done as a fixed point problem. We can first note that this problem is a contraction mapping problem. In this particular example this means that if we define a sequence <span>$\bar{f}_0 = f_0$</span> where <span>$f_0$</span> is some initial guess and <span>$f_i = g(f_{i-1})$</span> where <span>$g$</span> is given by the IterateOnce function below then this sequence will be convergent. Convergence would be slow however so below we will actually use the Anderson method:</p><pre><code class="language-none">using Distributions
using FixedPointAcceleration
using HCubature
using Optim
using Random
using SchumakerSpline
delta = 0.2
beta = 0.95
periodic_income = 1.0
shock_var = 1.0
shock_process = LogNormal(0.0, shock_var)
BudgetStateSpace = vcat( collect(0:0.015:periodic_income), collect(1.05:0.05:(3*periodic_income)))
InitialGuess = sqrt.(BudgetStateSpace)

function ValueGivenShock(Budget::Float64, epsilon::Float64, NextValueFunction::Schumaker)
    opt = optimize(x -&gt;  -1.0*(epsilon*(x^delta) + beta*evaluate(NextValueFunction, Budget - x + periodic_income)), 0.0, Budget)
    return -1.0 * opt.minimum
end

function ExpectedUtility(Budget::Float64, NextValueFunction::Schumaker)
    if Budget &gt; 0.00001
        integ = hcubature(epsilon-&gt; ValueGivenShock(Budget, epsilon[1], NextValueFunction)* pdf(shock_process, epsilon[1]), [quantile(shock_process,0.0001)], [quantile(shock_process, 0.9999)])
        return integ[1]
    else
        return beta * evaluate(NextValueFunction, periodic_income)
    end
end

function OneIterateBudgetValues(BudgetValues::Array{Float64,1})
    NextValueFunction = Schumaker(BudgetStateSpace, BudgetValues)
    new_budget_values = zeros(length(BudgetStateSpace))
    for i in 1:length(BudgetStateSpace)
        new_budget_values[i] = ExpectedUtility(BudgetStateSpace[i], NextValueFunction)
    end
    return new_budget_values
end

fp_anderson = fixed_point(OneIterateBudgetValues, InitialGuess; Algorithm = Anderson, PrintReports = true)
fp_simple   = fixed_point(OneIterateBudgetValues, InitialGuess; Algorithm = Simple, PrintReports = true)</code></pre><p>This takes 22 iterates with the Anderson algorithm which is drastically better than the 459 iterates it takes with the simple method.</p><footer><hr/><a class="previous" href="../4___ExpectationMaximisation/"><span class="direction">Previous</span><span class="title">-</span></a><a class="next" href="../5_TerminationConditions/"><span class="direction">Next</span><span class="title">5 Termination conditions and Error handling.</span></a></footer></article></body></html>
